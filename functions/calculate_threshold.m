function [classinfo] = calculate_threshold(input_directory, on_directories, off_directories, out_file, varargin)
% CALCULATE_THRESHOLD  calculates MFI threshold to distinguish ON/OFF colonies, based on control ON and OFF datasets
% 
%                INPUT_DIRECTORY  directory and subdirectories where control data is
% OFF_DIRECTORIES,ON_DIRECTORIES  cell array of subdirectories within `INPUT_DIRECTORY`; each subdirectory 
%                                 should contain one or more .DAT files with MFI data from a single frame
%                                 from the channel of interest
%                       OUT_FILE  specify where the classification data should be saved
% 
% Returns `classinfo`, a table with the following columns; also saves as `out_file`, a  CSV file with the same columns:
%     frame : frame number
%     threshold : threshold intensity separating ON from OFF colonies
%     LCI : lower bound of 95% confidence interval on `threshold`
%     UCI : upper bound of 95% confidence interval on `threshold`
% `out_file` can be used in `classify_colonies.m` to classify experimental colonies as ON, OFF, or MIXED
%
% Optional named parameters: 
%        'DatFilePattern'  how should the .DAT files be named? must include at least 
%                          `(?<frame>\d+)` placeholder indicating the frame number; 
%                          Default: '^(?<image>.*)-GFP-(?<frame>\d+)\.dat'
%                          (for example, this particular pattern recognizes files like:
%                             Some_experiment_name-GFP-12.dat
%                          where the frame number is 12)
% 
%    'TrainingSetIndices'  specify which indices to use to train the model and which to use to test it. 
%                          if you leave these empty, the indices will be chosen to withhold the first 20% 
%                          of the data for testing.
%        'TestSetIndices'
% 
% 
% Daniel Lee, Christina Lin, and Casey Grun
% MIT License

p = inputParser;
st = dbstack;
p.FunctionName = st.name;
p.StructExpand = false;

addParameter(p,'DatFilePattern',  '^(?<image>.*)-GFP-(?<frame>\d+)\.dat');
addParameter(p,'CsvFilePattern',  '');

addParameter(p,'TrainingSetIndices', []);
addParameter(p,'TestSetIndices', []);

parse(p,varargin{:})
args = p.Results;
DAT_FILE_PATTERN = args.DatFilePattern;
CSV_FILE_PATTERN = args.CsvFilePattern;
trainingsetinds = args.TrainingSetIndices;
testsetinds = args.TestSetIndices;


% specify directory and subdirectories where control data is, each generated by GFP_MFI_parse.m (one folder per
% colony).
INPUT_DIRECTORY=input_directory; %'control_data';

% specify a list of subdirectories within `INPUT_DIRECTORY`, each of which 
% should contain one or more .DAT files with MFI data from a single frame
% from the channel of interest
NEGATIVE_CONTROL_DIRECTORIES=off_directories;%{'PA14 exsA Pt-sfGFP MinS_NTA s1 col1','PA14 exsA Pt-sfGFP MinS_NTA s1 col2','PA14 exsA Pt-sfGFP MinS_NTA s3 col3','PA14 exsA Pt-sfGFP MinS_NTA s3 col4','PA14 exsA Pt-sfGFP MinS_NTA s4 col5'};
POSITIVE_CONTROL_DIRECTORIES=on_directories;%{'PA14 exsD Pt-sfGFP s1 col1','PA14 exsD Pt-sfGFP s3 col2','PA14 exsD Pt-sfGFP s4 col3','PA14 exsD Pt-sfGFP s4 col4','PA14 exsD Pt-sfGFP s4 col5'};

% specify where the classification data should be saved
OUT_FILE = out_file; %'F:\Dropbox\Christina_scripts_for_github_upload\class_info.csv'


% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  
%%
function [mfi, tvec] = load_control_data(directories)
    mfi = {};
    tvec = {};
    for colony=1:length(directories)
        directory = directories{colony};
        fnames = {};
        
        if ~isempty(CSV_FILE_PATTERN)
            dirobj = dir(fullfile(directory,'**','*.csv'));
            [fnames{1:length(dirobj)}]=dirobj(:).name;
            
            % for each csv file
            for ii=1:length(dirobj)
                %load .csv file
                filename = fullfile(directory, fnames{t});
                file_name_parts = regexp(fnames{t}, CSV_FILE_PATTERN, 'names');
                if (isempty(file_name_parts))
                    fprintf('Skipping .csv file "%s" which does not fit the expected naming pattern\n', fnames{t})
                    continue
                end
                data = load(filename);
                
                timepoints = unique(data.tframe);
                
                for t = 1:length(timepoints)
                    mfi{t,colony} = [mfi{t,colony} data.MFI_GFP(data.tframe == t)];
                    tvec{t,colony} = [tvec{t,colony} timepoints(t)]; %str2num((filename((max(find(filename=='_'))+2):(max(find(filename=='.'))-1)))); 
                end
            end
                
        else

            dirobj = dir(fullfile(directory,'**','*.dat'));
            [fnames{1:length(dirobj)}]=dirobj(:).name;

            % for each timepoint
            for t=1:length(dirobj)
                %load .dat file
                filename = fullfile(directory, fnames{t});
                file_name_parts = regexp(fnames{t}, DAT_FILE_PATTERN, 'names');
                if (isempty(file_name_parts))
                    fprintf('Skipping .dat file "%s" which does not fit the expected naming pattern\n', fnames{t})
                    continue
                end

                mfi{t,colony} = load(filename);
                tvec{t,colony} = str2double(file_name_parts.frame); %str2num((filename((max(find(filename=='_'))+2):(max(find(filename=='.'))-1))));
            end
        end
    end 
end

% load data from the negative control samples (fluorescence OFF)
[mfi_OFF, tvec_OFF] = load_control_data(fullfile(INPUT_DIRECTORY, NEGATIVE_CONTROL_DIRECTORIES));

% load data from the positive control samples (fluorescence ON)
[mfi_ON, tvec_ON] = load_control_data(fullfile(INPUT_DIRECTORY, POSITIVE_CONTROL_DIRECTORIES));

% find timepoints for which there are both ON and OFF colonies
tvals = intersect(...
    unique(cell2mat(tvec_OFF)),... 
    unique(cell2mat(tvec_ON))...
);

% automatically partition dataset into test and training
n_colonies_OFF = size(mfi_OFF);
n_colonies_ON = size(mfi_ON);
if n_colonies_OFF(2) ~= n_colonies_ON(2)
   ME = MException('Must have same number of ON as OFF colonies');
   throw(ME);
elseif n_colonies_OFF(2) == 0
   ME = MException('Must more than zero colonies');
   throw(ME);
end
n_colonies = n_colonies_OFF(2);
if isempty(trainingsetinds) && isempty(testsetinds)
    if n_colonies  < 2
        ME = MException('Must 2+ colonies'); throw(ME);
    end
    % the test set will be at least 20% of the colonies
    test_set_size = max(ceil(0.2*n_colonies), 1);
    testsetinds     = 1:test_set_size;
    trainingsetinds = test_set_size:n_colonies;
end
fprintf(['Calculating threshold for %d timepoints, using %d colonies '... 
    'for training and %d colonies to test model...\n'],...
    length(tvals), length(trainingsetinds), length(testsetinds))

% for each timepoint
for tind=1:length(tvals)
    timepoint=tvals(tind);
    fprintf('- Timepoint %d/%d (frame %d)...\n',tind, length(tvals), timepoint)
    [inds_OFF] = find([tvec_OFF{:}] == timepoint);
    [inds_ON]  = find([tvec_ON{:}]  == timepoint);
    trainingset=[[mfi_OFF{inds_OFF(trainingsetinds)}]' zeros(size([mfi_OFF{inds_OFF(trainingsetinds)}]')) ;
                 [mfi_ON{inds_ON(trainingsetinds)}]' ones(size([mfi_ON{inds_ON(trainingsetinds)}]'))];
    mean_OFF = nanmean(trainingset(trainingset(:,2)==0,1));
    std_OFF  = nanstd(trainingset(trainingset(:,2)==0,1),0);
    mean_ON = nanmean(trainingset(trainingset(:,2)==1,1));
    std_ON  = nanstd(trainingset(trainingset(:,2)==1,1),0);
    
    testset=[[mfi_OFF{inds_OFF(testsetinds)}]' zeros(size([mfi_OFF{inds_OFF(testsetinds)}]')) ;
             [mfi_ON{inds_ON(testsetinds)}]' ones(size([mfi_ON{inds_ON(testsetinds)}]'))];
    testints=0:0.5:1800;
    La=normpdf(testints,mean_OFF,std_OFF); %plot gaussian based on sample mean and SD
    Ld=normpdf(testints,mean_ON,std_ON);
    K=La./Ld; %calculate likelihood ratio of positive/negative
    ps=chi2cdf(-2*log(K),1); %calculate probability based on likelihood ratio as a function of intensity
    threshval(tind)=polyxpoly(testints,ps,1:length(ps),.5*ones(size(ps))); %threshold is found at equal likelihood
    upperval(tind)=polyxpoly(testints,ps,1:length(ps),.95*ones(size(ps))); %upper confidence interval at 95%
    lowerval(tind)=polyxpoly(testints,ps,1:length(ps),.05*ones(size(ps))); %lower confidence interval at 5%
    %note that settings corrections need to be applied after this
end

%%
%save and output classification information as a table
classinfo=table(tvals,threshval',lowerval',upperval','VariableNames',{'frame','threshold','LCI','UCI'});
writetable(classinfo,OUT_FILE);

%%
%Plot histogram of ExsA and ExsD GFP MFIs and Calculating Threshold for T3SS-ON vs OFF.
figure
subplot(3,1,1)
histogram(trainingset(trainingset(:,2)==1),'Normalization','pdf','BinMethod','sqrt')

%output summary plots
subplot(3,1,1)
for i = 1:length(tvals)
    mfis_OFF =[mfi_OFF{find([tvec_OFF{:}]==tvals(i))}];
    mfis_ON  =[ mfi_ON{find([tvec_ON{:}] ==tvals(i))}];
    [x h]=histcounts([mfis_OFF mfis_ON],'BinMethod','sqrt','Normalization','Count');
    BW=mean(diff(h));
    histogram(mfis_OFF,'BinWidth',BW,'Normalization','pdf','FaceColor','k','FaceAlpha',0.2)
    hold on
    plot(testints,La,'-k','LineWidth',2)
    histogram(mfis_ON,'BinWidth',BW,'Normalization','pdf','FaceColor','g','FaceAlpha',0.2)
    plot(testints,Ld,'-g','LineWidth',2)
    xlim([0 1800])
    %title(['frame' num2str(tvals(i))])
    mean_OFF(i)=nanmean(mfis_OFF);
    
    std_OFF(i)=nanstd(mfis_OFF);
    mean_ON(i)=nanmean(mfis_ON);
    std_ON(i)=nanstd(mfis_ON);
end
box off
ylabel('PDF')

legend({'OFF','OFF Gaussian PDF','ON','ON Gaussian PDF'})

subplot(3,1,2)
hold on
plot(testints,log(K),'.k')
BFdata=log(normpdf(testset(:,1),mean_OFF,std_OFF)./normpdf(testset(:,1),mean_ON,std_ON));

%gscatter(testset(:,1),BFdata,testset(:,2))
plot(testints,zeros(size(testints)),'m.-')
%xlabel('Intensity')
ylabel('log(L_{OFF}/L_{ON})')
ylim([-100 100])
xlim([0 1800])

subplot(3,1,3)
box off
%pinds=(max(find(ps==min(ps))):min(find(ps==max(ps))))
%interp1(ps(pinds),testints(pinds),[0.05 0.5 .95]);
plot(testints,ps,'k.-')
ylim([-.05 1.05])
xlim([0 1800])
ylabel('p')
hold on
plot(testints,ones(size(testints)).*.05,'m--')
plot(testints,ones(size(testints)).*.95,'m--')
plot(testints,ones(size(testints)).*.5,'m.-')
xlabel('Mean Fluorescence Intensity')
ylabel('p_{OFF}')
%%
hours=transpose((tvals-1)./4);
figure;
errorbar(hours,mean_OFF,std_OFF,'.g');
hold on
errorbar(hours,mean_ON,std_ON,'.k');
xlabel('Time (hours)')
ylabel('Intensity (AU)')
xlim([-2 8])
set(gca,'TickDir','out')
box off
threshval_3s=1.32+threshval;
errorbar(hours,threshval,threshval-lowerval,upperval-threshval,'.m');

end