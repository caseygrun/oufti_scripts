function [classinfo] = calculate_threshold(off_files, on_files, out_file, varargin)
% CALCULATE_THRESHOLD  calculates MFI threshold to distinguish ON/OFF colonies, based on control ON and OFF datasets
% Assumes that, at each timepoint, the MFIs for ON and OFF colonies will be
% Gaussian. Determines, at each timepoint, the MFI for which the likelihood
% of a cell being ON equals the likelihood of being OFF. Also calculates
% the 95% confidence interval on this parameter. 
%
%             OFF_FILES,ON_FILES  cell array or glob string of paths to 
%                                 CSV files; each .CSV file should contain
%                                 one ON or OFF microcolony. There should
%                                 be the same number of ON and OFF
%                                 microcolonies
%                       OUT_FILE  path where the classification data should 
%                                 be saved (this is the same as the data
%                                 which is returned)
% 
% Returns `classinfo`, a table with the following columns; also saves as `out_file`, a  CSV file with the same columns:
%     frame : frame number
%     threshold : threshold intensity separating ON from OFF colonies
%     LCI : lower bound of 95% confidence interval on `threshold`
%     UCI : upper bound of 95% confidence interval on `threshold`
% `out_file` can be used in `classify_colonies.m` to classify experimental colonies as ON, OFF, or MIXED
%
% Optional named parameters: 
%               'Channel'  which channel to use for calculations (defaults
%                          to 'GFP'). A column named ['MFI_' channel] will
%                          be searched for in the input CSV files. 
%    'TrainingSetIndices'  specify which indices to use to train the model and which to use to test it. 
%                          if you leave these empty, the indices will be chosen to withhold the first 20% 
%                          of the data for testing.
%        'TestSetIndices'
% 'MFIRangeForLikelihood'  the likelihood for ON and OFF colonies
%         'FrameDuration'  the length of each frame, in hours (defaults to
%                          0.25); for plotting only
%       'PlotLikelihoods'  plot ON and OFF likelihood model for each frame
%        'PlotThresholds'  plot threshold values and distribution of ON/OFF
%                          MFIs
% 
% Daniel Lee, Christina Lin, and Casey Grun
% MIT License

p = inputParser;
st = dbstack;
p.FunctionName = st.name;
p.StructExpand = false;

addParameter(p,'DatFilePattern',  '^(?<image>.*)-GFP-(?<frame>\d+)\.dat');
addParameter(p,'CsvFilePattern',  '');

addParameter(p,'TrainingSetIndices', []);
addParameter(p,'TestSetIndices', []);
addParameter(p,'Channel','GFP');
addParameter(p,'MFIRangeForLikelihood',[0:0.5:1800]);
addParameter(p,'PlotLikelihoods',true);
addParameter(p,'PlotThresholds',true);

parse(p,varargin{:})
args = p.Results;
DAT_FILE_PATTERN = args.DatFilePattern;
CSV_FILE_PATTERN = args.CsvFilePattern;
trainingsetinds = args.TrainingSetIndices;
testsetinds = args.TestSetIndices;
testints=args.MFIRangeForLikelihood;

CHANNEL = args.Channel;

if args.PlotLikelihoods
    figure;
end

% specify directory and subdirectories where control data is, each generated by GFP_MFI_parse.m (one folder per
% colony).
% INPUT_DIRECTORY=input_directory; %'control_data';

% specify a list of subdirectories within `INPUT_DIRECTORY`, each of which 
% should contain one or more .DAT files with MFI data from a single frame
% from the channel of interest
NEGATIVE_CONTROL_DIRECTORIES=off_files;%{'PA14 exsA Pt-sfGFP MinS_NTA s1 col1','PA14 exsA Pt-sfGFP MinS_NTA s1 col2','PA14 exsA Pt-sfGFP MinS_NTA s3 col3','PA14 exsA Pt-sfGFP MinS_NTA s3 col4','PA14 exsA Pt-sfGFP MinS_NTA s4 col5'};
POSITIVE_CONTROL_DIRECTORIES=on_files;%{'PA14 exsD Pt-sfGFP s1 col1','PA14 exsD Pt-sfGFP s3 col2','PA14 exsD Pt-sfGFP s4 col3','PA14 exsD Pt-sfGFP s4 col4','PA14 exsD Pt-sfGFP s4 col5'};

% specify where the classification data should be saved
OUT_FILE = out_file; %'F:\Dropbox\Christina_scripts_for_github_upload\class_info.csv'


% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  
%%

isTableCol = @(t, thisCol) ismember(thisCol, t.Properties.VariableNames);

function [mfi, tvec] = load_control_data(files)
    mfi = {};
    tvec = {};
    
    % if this is a single character array, assume its a glob pattern
    if ischar(files)
        files = dir(files);
        
        % get the complete file path (folder / name) for each matched file
        files = arrayfun(@(x) fullfile(x.folder,x.name), files, 'UniformOutput', false);
    else
        if ~iscellstr(files)
            error(['ON_FILES and OFF_FILES must be either a cell array of '...
                'characters or a glob patern matching one or more CSV '...
                'files each.'])
        end
    end
    
    for colony=1:length(files)
        file = files{colony};
        
        data = readtable(file);
        timepoints = unique(data.tframe);
        
        if isempty(mfi)
            mfi = cell(length(timepoints),length(files));
            tvec = zeros(length(timepoints),length(files));
        end
        
        if ~isTableCol(data, ['MFI_' CHANNEL])
            error(['Could not find column "%s" in file "%s". Check '...
                'whether the ''Channel'' argument is correct.'],...
                ['MFI_' CHANNEL], file);
        end
        channel_mfis = data.(['MFI_' CHANNEL]);
        for t = 1:length(timepoints)
            frame = timepoints(t);
            mfi{t,colony} = [mfi{t,colony} channel_mfis(data.tframe == frame)];
            tvec(t,colony) = timepoints(t); %str2num((filename((max(find(filename=='_'))+2):(max(find(filename=='.'))-1)))); 
        end

    end 
end

%%
%Plot histogram of OFF and ON MFIs and threshold likelihood, for a single
%frame. 
function plot_likelihood(i, nframes)
%     subplot(3,1,1)
%     histogram(trainingset(trainingset(:,2)==1),'Normalization','pdf','BinMethod','sqrt')

    %output summary plots
    subplot(3,nframes,i)
%         for i = 1:length(tvals)
        mfis_OFF =vertcat(mfi_OFF{i, :});
        mfis_ON  =vertcat( mfi_ON{i, :});
        [x,h]=histcounts([mfis_OFF' mfis_ON'],'BinMethod','sqrt','Normalization','Count');
        BW=mean(diff(h));
        histogram(mfis_OFF,'BinWidth',BW,'Normalization','pdf','FaceColor','k','FaceAlpha',0.2)
        hold on
        plot(testints,La,'-k','LineWidth',2)
        histogram(mfis_ON,'BinWidth',BW,'Normalization','pdf','FaceColor','g','FaceAlpha',0.2)
        plot(testints,Ld,'-g','LineWidth',2)
        xlim([min(testints) max(testints)]);
        %title(['frame' num2str(tvals(i))])
%         end
    box off
    ylabel('PDF')
    
    if(i==nframes), legend({'OFF','OFF Gaussian PDF','ON','ON Gaussian PDF'})
    else, legend(gca(),'off')
    end

    subplot(3,nframes,nframes+i)
    hold on
    plot(testints,log(K),'.k')
%     BFdata=log(normpdf(testset(:,1),mean_OFF(i),std_OFF(i))./normpdf(testset(:,1),mean_ON(i),std_ON(i)));
%     gscatter(testset(:,1),BFdata,testset(:,2))
    plot(testints,zeros(size(testints)),'m.-')
    %xlabel('Intensity')
    ylabel('log(L_{OFF}/L_{ON})')
    ylim([-100 100])
    xlim([min(testints) max(testints)]);
    legend(gca(),'off');
    
    subplot(3,nframes,2*nframes+i)
    box off
    %pinds=(max(find(ps==min(ps))):min(find(ps==max(ps))))
    %interp1(ps(pinds),testints(pinds),[0.05 0.5 .95]);
    plot(testints,ps,'k.-')
    ylim([-.05 1.05])
    xlim([min(testints) max(testints)]);
    hold on
    plot(testints,ones(size(testints)).*.05,'m--')
    plot(testints,ones(size(testints)).*.5,'m.-')
    plot(testints,ones(size(testints)).*.95,'m--')
    if(i==nframes), legend({'p','0.05','0.5','0.95'})
    else, legend(gca(),'off')
    end
    xlabel('MFI')
    ylabel('p_{OFF}')

end

%%
function plot_thresholds()
    hours=transpose((tvals-1).*frame_duration);
    figure;
    errorbar(hours,mean_OFF,std_OFF,'.k');
    hold on
    errorbar(hours,mean_ON,std_ON,'.g');
    xlabel('Time (hours)')
    ylabel('MFI (AU)')
    xlim([-2 8])
    set(gca,'TickDir','out')
    box off
    % threshval_3s=1.32+threshval;
    errorbar(hours,threshval,threshval-lowerval,upperval-threshval,'.m');
    legend({'OFF','ON','Threshold'})
end


% load data from the negative control samples (fluorescence OFF)
[mfi_OFF, tvec_OFF] = load_control_data(NEGATIVE_CONTROL_DIRECTORIES);

% load data from the positive control samples (fluorescence ON)
[mfi_ON, tvec_ON] = load_control_data(POSITIVE_CONTROL_DIRECTORIES);

% find timepoints for which there are both ON and OFF colonies
tvals = intersect(...
    unique(tvec_OFF),... 
    unique(tvec_ON)...
);

% automatically partition dataset into test and training
n_colonies_OFF = size(mfi_OFF);
n_colonies_ON  = size(mfi_ON);
if n_colonies_OFF(2) ~= n_colonies_ON(2)
   error('Must have same number of ON as OFF colonies');
elseif n_colonies_OFF(2) == 0
   error('Must have more than zero colonies');
end
n_colonies = n_colonies_OFF(2);
if isempty(trainingsetinds) && isempty(testsetinds)
    if n_colonies  < 2
        error('Must have 2+ colonies');
    end
    % the test set will be at least 20% of the colonies
    test_set_size = max(ceil(0.2*n_colonies), 1);
    testsetinds     = 1:test_set_size;
    trainingsetinds = test_set_size:n_colonies;
end
fprintf(['Calculating threshold for %d timepoints, using %d colonies '... 
    'for training and %d colonies to test model...\n'],...
    length(tvals), length(trainingsetinds), length(testsetinds))

% for each timepoint
threshval = zeros(length(tvals),1);
upperval = zeros(length(tvals),1);
lowerval = zeros(length(tvals),1);

mean_OFF = zeros(length(tvals),1);
std_OFF  = zeros(length(tvals),1);
mean_ON  = zeros(length(tvals),1);
std_ON   = zeros(length(tvals),1);

for tind=1:length(tvals)
    timepoint=tvals(tind);
    fprintf('- Timepoint %d/%d (frame %d)...\n',tind, length(tvals), timepoint)
    [inds_OFF] = find(tvec_OFF == timepoint);
    [inds_ON]  = find(tvec_ON  == timepoint);
    mfi_OFF_train = vertcat(mfi_OFF{tind, trainingsetinds});
    mfi_ON_train  = vertcat( mfi_ON{tind, trainingsetinds});
    
    trainingset = [[mfi_OFF_train zeros(size(mfi_OFF_train))];
                   [mfi_ON_train  ones(size(mfi_ON_train))  ]];
                 
%     trainingset=[[mfi_OFF{inds_OFF(trainingsetinds)}]' zeros(size([mfi_OFF{inds_OFF(trainingsetinds)}]')) ;
%                  [mfi_ON{inds_ON(trainingsetinds)}]' ones(size([mfi_ON{inds_ON(trainingsetinds)}]'))];
    mean_OFF(tind) = nanmean(trainingset(trainingset(:,2)==0,1));
    std_OFF(tind)  = nanstd(trainingset(trainingset(:,2)==0,1),0);
    mean_ON(tind) = nanmean(trainingset(trainingset(:,2)==1,1));
    std_ON(tind)  = nanstd(trainingset(trainingset(:,2)==1,1),0);
    
    mfi_OFF_test = vertcat(mfi_OFF{tind, testsetinds});
    mfi_ON_test  = vertcat( mfi_ON{tind, testsetinds});
    testset = [[mfi_OFF_test zeros(size(mfi_OFF_test))];
               [mfi_ON_test  ones(size(mfi_ON_test))  ]];
    
%     testset=[[mfi_OFF{inds_OFF(testsetinds)}]' zeros(size([mfi_OFF{inds_OFF(testsetinds)}]')) ;
%              [mfi_ON{inds_ON(testsetinds)}]' ones(size([mfi_ON{inds_ON(testsetinds)}]'))];
    
    La=normpdf(testints,mean_OFF(tind),std_OFF(tind)); %plot gaussian based on sample mean and SD
    Ld=normpdf(testints,mean_ON(tind),std_ON(tind));
    K=La./Ld; %calculate likelihood ratio of positive/negative
    ps=chi2cdf(-2*log(K),1); %calculate probability based on likelihood ratio as a function of intensity
    thresh = polyxpoly(testints,ps,1:length(ps),.5*ones(size(ps))); %threshold is found at equal likelihood
    upp = polyxpoly(testints,ps,1:length(ps),.95*ones(size(ps))); %upper confidence interval at 95%
    low = polyxpoly(testints,ps,1:length(ps),.05*ones(size(ps))); %lower confidence interval at 5%
    %note that settings corrections need to be applied after this
    
    if (isempty(thresh) || isempty(upp) || isempty(low))
        error(['  ! Could not solve likelihood for threshold at timepoint '...
            '%d; consider adjusting ''MFIRangeForLikelihood''. '...
            'Threshold: %d, 95% CI = [%d %d]'], timepoint, thresh, upp, low)
    end
    if ((length(thresh) > 1) || (length(thresh) > 1) || (length(thresh) > 1))
       warning(sprintf(['  ! Identified multiple estimates for threshold at '...
           'timepoint %d: Threshold: %d, 95%% CI = [%d %d]'],... 
           timepoint, thresh, upp, low)) %#ok<SPWRN>
       
    end
    
    threshval(tind)=max(thresh);
    upperval(tind)= max(upp);
    lowerval(tind)= max(low);
    
    if args.PlotLikelihoods
        plot_likelihood(tind,length(tvals))
    end
    
end

%%
%save and output classification information as a table
classinfo=table(tvals,threshval,lowerval,upperval,'VariableNames',{'frame','threshold','LCI','UCI'});
writetable(classinfo,OUT_FILE);

if args.PlotThresholds
    plot_thresholds()
end


end